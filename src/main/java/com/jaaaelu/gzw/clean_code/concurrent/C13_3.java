package com.jaaaelu.gzw.clean_code.concurrent;

public class C13_3 {
    //  13.3 并发防御原则

    //  13.3.1 单一权责原则

    //  单一权责原则认为，方法/类/组件应该只有一个修改的理由。并发设计自身足够复杂到成为修改的理由，所以也该从其他代码中
    //  分离出来。不幸的是，并发实现细节常常嵌入到生产代码中。下面是要考虑的一些问题：
    //  - 并发相关代码有自己的开发、修改和调优生命周期
    //  - 开发相关代码有自己要应付的挑战，和非并发相关代码不同，而且往往更为困难
    //  - 即便没有周边应用程序增加负担，写的不好的并发代码可能的出错方式数量也已经足具挑战性
    //  建议：分离并发相关代码和其他代码

    //  13.3.2 推论：限制数据作用域

    //  如我们所见：两个线程修改共享对象的同一字段时，可能互相干扰，导致未预期的行为。解决方案之一是采用 synchronized 关
    //  键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越可能：
    //  - 你会忘记保护一个或多个临界区——破坏了修改共享数据的代码
    //  - 得多花力气保证一切都受到有效防护
    //  - 很难找到错误源，也很难判断错误源
    //  建议：谨记数据封装；严格限制对数据被共享的数据访问

    //  13.3.3 推论：使用数据复本

    //  避免共享数据的方法之一就是一开始就避免共享数据。在某些情形下，有可能复制对象并以只读的方式对待。在另外的情况下，
    //  有可能复制对象，从多个线程收集所有复本的结果，并在单个线程中合并这些结果（？？？）
    //  你可能担心创建额外对象的成本，值得试验一下看看那是否是个问题。然而，假使使用对象复本能避免代码同步执行，则因避免
    //  了锁定而省下的的价值可能补偿得上额外的创建成本和垃圾收集开销

    //  13.3.4 推论：线程应尽可能地独立

    //  让每个线程在自己的世界存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳请求数据，存储为
    //  本地变量。这样依赖，每个线程都像是世界中的唯一线程，没有同步需要
    //  尝试将数据分解到可被独立线程操作的独立子集
}
