package com.jaaaelu.gzw.clean_code.concurrent;

public class C13_0__13_2 {
    //  13.0 并发编程

    //  对象是过程的抽象。线程是调度的抽象

    //  13.1 为什么要并发

    //  并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。在单线程应用中，目的和时机紧密耦合，调试这
    //  种系统的程序可以设定断点

    //  解耦目的和时机能明显的改进应用程序的吞吐量和结构，从结构的的角度来看，应用程序看起来更像是许多台协同工作的计算机，
    //  而不是一个大循环。系统因此会更易于被理解，给出了许多切分关注面的有力手段

    //  但结构并非采用并发的唯一冬季，有些系统对响应时间和吞吐量有要求，需要手工编写并发解决方案

    //  迷思与误解

    //  看来有足够的理由改进性能

    //  （1）并发总能改进性能：并发有时能改进性能，但只在多个线程或处理之间能分享大量等待时间的时候管用
    //  （2）编写并发无需修改设计：目的与时机的解耦汪汪对系统结构产生巨大影响
    //  （3）在采用 Web 和 EJB 容器的时候，理解并发问题并不重要

    //  下面是一些有关冰鞋并发软件的中肯说法：
    //  - 并发会在性能和编写额外代码上增加一些开销
    //  - 正确的并发是复杂的，即便对于简单的问题也是如此
    //  - 并发缺陷并非总能重现，所以常被看作偶发事件而忽略，未被当做真的缺陷来看待
    //  - 并发尝尝需要对设计策略根本性的修改

    //  13.2 挑战

    //  并发编程为何如此之难？来看看下面这个例子：

    public class X {
        private int lastIdUsed;

        public int getNextId() {
            return ++lastIdUsed;
        }
    }

    //  比如，创建 x 的实体，将 lastIdUsed 设置为 42，现在两个两个线程中共享这个实体。假设这两个线程都调用了 getNextId()
    //  方法，结果可能有三种输出：
    //  - 线程一得到值 43，线程二得到值 44，lastIdUsed 为 44
    //  - 线程一得到值 44，线程二得到值 43，lastIdUsed 为 44
    //  - 线程一得到值 43，线程二得到值 43，lastIdUsed 为 43
    //  第三种结果令人差异，当两个线程互相影响时就会出现这种情况
    //  线程在执行 Java 代码时有许多可能的路径可行，而有些路径会产生错误的结果。但有多少种不同路径呢？想要真的回答这个问
    //  题，就需要去理解编译器如果对待生成的字节码，以及理解 Java 内存模型认为什么东西具有原子性
    //  简单回答，就于生成字节码而言，对于在 getNextId 方法中执行的那两个线程，有 12870 种不同的可能执行路径，而如果将
    //  lastIdUsed 由 int 改为 long，那么则可能的路径的数量将增至 2704156 中。当然，多数路径都得到正确结果。问题是其中一
    //  些不能得到正确结果
}
