package com.jaaaelu.gzw.clean_code.concurrent;

public class C13_4__13_5 {
    //  13.4 了解 Java 库

    //  相对于之前的版本，Java 5 提供了许多并发开发的改进。在用 Java 5 编写线程代码时，要注意以下几点：
    //  - 使用类库提供的线程安全群集
    //  - 使用 executor 框架执行无关任务
    //  - 尽可能使用非锁定解决方案
    //  - 有几个类并不是线程安全的

    //  线程安全群集
    //  几乎所有情况下，ConcurrentHashMap 实现都比 HaspMap 表现得好
    //  几个支持高级并发设计的类
    //  - ReentrantLock (可在一个方法中获取、在另一个方法中释放的锁)
    //  - Semaphore (经典的“信号”的一种实现，有计数器的锁)
    //  - CountDownLatch (在释放所有等待的线程之前，等待指定数量事件发生的锁。这样，所有线程都平等地几乎同时启动)

    //  13.5 了解执行模型

    //  有几种在并发应用中切分行为的途径。要讨论这些途径，我们需要理解一些基础定义：
    //  - 限定资源：并发环境中有着固定尺寸或者数量的资源。例如数据库链接和固定尺寸的读/写缓存等
    //  - 互斥：每一时刻仅有一个线程能访问或共享资源
    //  - 线程饥饿：一个或一组线程坐在很长时间内或永久被禁止了。例如，总是让执行的快的线程先运行，假如执行的快线程没完没
    //  了，则执行时间长的线程就会“挨饿”
    //  - 死锁：两个或多个线程互相等待执行结束。每个线程都拥有其他线程需要资源，得不到两个线程拥有的资源，就无法终止
    //  - 活锁：执行次序一致的线程，每个都想要起步，但发现其他线程已经“在路上”。由于竞步的原因，线程会持续尝试起步，但
    //  在很长时间却无法如愿，甚至永远无法启动
    //  有了这些定义，我们就能讨论在并发编程中用到的几种执行模型了

    //  13.5.1 生产者-消费者模型

    //  一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消
    //  费者之间的队列是一种限定资源

    //  13.5.2 读者-作者模型

    //  当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程
    //  饥饿和过时信息的累计。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的信息（反之亦然），这是一种辛苦的平
    //  衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题
    //  挑战之处在于平衡读者线程和作者线程的需求，实现正确操作，提供合理的吞吐量，避免线程饥饿

    //  13.5.3 宴席哲学家

    //  一群哲学家围在圆桌旁，桌子的中间放着一大碗意大利面，但是由于餐具有限，所以每位哲学家只能依次吃。用线程替代哲学家，
    //  用资源代替叉子，如果程序没有用心设计，就会出现应用中进程竞争资源的情形，这种竞争关系就会遭遇死锁、活锁、吞吐量和
    //  效率降低等问题
    //  建议：学习这些基础算法，理解其解决方案
}
