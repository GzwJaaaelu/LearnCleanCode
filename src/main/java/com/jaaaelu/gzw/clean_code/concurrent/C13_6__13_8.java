package com.jaaaelu.gzw.clean_code.concurrent;

public class C13_6__13_8 {
    //  13.6 警惕同步方法之间的依赖

    //  同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java 语言中有 synchronized 概念，可以用来保护单个同步方法。然而，如
    //  果在同一共享类中使用有多个同步方法，系统就可能写的不太正确了
    //  建议：避免一个共享对象的多个方法
    //  如果必须使用一个共享对象的多个方法，这时有三种写对代码保护的手段：
    //  - 基于客户端的锁定——客户端代码在调用第一个方法前锁定服务器，确保锁的范围覆盖了调用最后一个方法的代码
    //  - 基于服务端的锁定——在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新方法
    //  - 适配服务端——创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务器端代码

    //  13.7 保持同步区域微小

    //  关键字 synchronized 制造了锁。同一个锁维护的所有代码区域在任一时刻保证只有一个线程执行。锁是昂贵的，因为它们带来
    //  了延迟和额外开销。所以我们不愿意将代码扔给 synchronized 了事
    //  建议：尽可能减小同步区域

    //  13.8 很难编写正确的关闭代码

    //  编写永远运行的系统，与编写运行一段时间后平静地关闭的系统是两码事
    //  平静关闭很难做到，常见问题与死锁有关，线程一直等待永远不会到来的信号

    //  建议：尽早考虑关闭问题，尽早令其工作正常。这会话费比你预期更多的时间。检视既有算法，因为这可能会比想象中难得多
}
