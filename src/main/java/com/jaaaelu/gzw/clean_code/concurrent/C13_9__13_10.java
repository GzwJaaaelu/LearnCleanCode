package com.jaaaelu.gzw.clean_code.concurrent;

import java.util.Iterator;
import java.util.List;

public class C13_9__13_10 {
    //  13.9 测试线程代码

    //  测试并不能确保正确性。然而，好的测试却能尽量降低风险。不过当有两个或者多个线程的时候使用同一代码段和共享数据，事
    //  情就变得非常复杂了

    //  建议：编写有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行。如果有测试失败，跟踪错误。别因为
    //  后来测试通过后来的运行就忽略失败
    //  有一大推问题要考虑。下面是一些精炼的建议：
    //  - 将伪失败看错可能的线程问题
    //  - 先使非线程代码可工作
    //  - 编写可插拔的线程代码
    //  - 编写可调整的线程代码
    //  - 运行多于处理器数量的线程
    //  - 在不同平台上运行
    //  - 调整代码并强迫错误发生

    //  13.9.1 将伪失败看错可能的线程问题

    //  多数开发者缺乏有关县城如何与其他代码互动的直觉。线程代码中的缺陷可能在一千或一百万次执行中才会显现一次。重复执行
    //  想要复现问题令人沮丧
    //  建议：不要将系统错误归咎与偶发事件

    //  13.9.2 先使非线程代码可工作

    //  建议：不要同时最终非线程缺陷和线程缺陷。确保代码在线程之外可工作

    //  13.9.3 编写可插拔的线程代码

    //  编写可在数个配置环境下运行的线程代码：
    //  - 单线程与多个线程在执行时不同的情况
    //  - 线程代码与实物或测试替身互动
    //  - 用运行快速、缓慢和有变动的测试替身执行
    //  - 将测试配置为能运行一定数量的迭代
    //  建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行

    //  13.9.4 编写可调整的线程代码

    //  要获得良好的线程平衡，常常需要试错。要允许线程数量可调整。允许线程依据吞吐量和系统使用率自我调整

    //  13.9.5 运行多于处理器数量的线程

    //  系统在切换任务时会发生一些事情。为了促使任务交换的发生，运行多于处理器或处理器核心数量的线程。任务交换越频繁，越
    //  有可能找到错过临界区或导致死锁的代码

    //  13.9.6 在不同平台上运行

    //  不同操作系统有着不同线程策略。不同的线程策略影响了代码的执行。在不同环境中，多线程代码也不一样。应该在所有可能不
    //  同的环境中运行测试
    //  建议：尽早并经常地在所有目标平台上运行线程代码

    //  13.9.7 装置试错代码

    //  并发代码中藏有缺陷，这并不罕见。简单的测试往往无法暴露这些缺陷。实际上，缺陷经常隐藏于一般处理过程中

    //  线程中的缺陷之所以如此不频繁、偶发、难以重现，是因为在几千个穿过脆弱区域的可能路径当中，只有少数路径会整的导致失败

    //  我们可以通过装置代码，增加对 Object.wait()、Object.sleep()、Object.yield() 和 Object.priority() 等方法的调用，改
    //  变代码执行顺序，从而增加侦测缺陷的可能性

    //  有两种装置代码的方法
    //  - 硬编码
    //  - 自动化

    //  13.9.8 硬编码

    //  你可以手动向代码插入 wait()、sleep()、yield() 和 priority() 的调用

    //  例：

    private Iterator<String> urls;

    public synchronized String nextUrlOrNull() {
        if (hasNext()) {
            //  随便写的逻辑
            String url = urls.next();
            //  插入为了测试
            Thread.yield();
            updateHasNext();
            return url;
        }
        return null;
    }

    private void updateHasNext() {
        //  TODO
    }

    private boolean hasNext() {
        //  TODO
        return false;
    }

    //  插入 yield() 调用，将改变代码的执行路径，由此而可能导致代码在以前未失败过的地方失败。如果代码的确出错，那并非是因
    //  为你插入了 yield() 方法调用。代码出错了，这便是失败的原因
    //  这种方法有许多毛病：
    //  - 你得手动找到合适的地方来插入方法调用
    //  - 你怎么知道在哪里插入调用、插入什么调用
    //  - 不必要地在产品环境中留下这类代码，将拖慢代码执行速度
    //  - 这是种无的放矢的手段。你可能找不到缺陷。实际上，这不在你把握之中

    //  13.9.9 自动化

    //  建议：使用异动策略搜出错误

    //  13.10 小结

    //  并发代码很难写正确。加入多线程共享数据后，简单的代码也会变成噩梦。要编写并发代码，就给严格的编写整洁的代码，否则
    //  将面临微细和不平凡的失败

    //  第一要诀是遵循单一权责原则

    //  了解并发问题的可能原因：对共享数据的多线程操作，或使用了公共资源池。类似平静关闭或定制循环子类边界情况尤其棘手

    //  学习如何找到必须锁定的代码区域并锁定之。不要锁定不必要的代码。避免从锁定区域调用其他锁定区域。尽可能减少共享对象
    //  和共享范围

    //  如果花点时间装置代码，就能极大地提升发现错误代码的机会
}
