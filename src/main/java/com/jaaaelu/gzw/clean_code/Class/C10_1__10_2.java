package com.jaaaelu.gzw.clean_code.Class;

import java.util.LinkedList;
import java.util.List;

public class C10_1__10_2 {
    //  10.1 类的组织

    //  遵循标准的 Java 约定，类应该从一组变量列表开始。如果有公共静态常量，应该先出现。然后是私有静态变量，以及私有实体
    //  变量。很少有公共变量

    //  公共函数应跟在变量列表之后。我们喜欢把由某个函数调用的私有工具函数紧随在该公共函数后面。这符合了自顶向下原则，让
    //  程序读起来就像一篇报纸文章

    //  10.2 类应该短小

    //  关于类的第一条规则是类应该短小。第二条规则是还要更短小

    //  不过，我们并不是重弹“函数”一章的论调。对于函数，我们通过计算代码行数衡量大小。对于类，我们采用不同的衡量方法，
    //  计算权责

    //  类的名称一个单描述其权责。实际上，命名正是帮助判断类的长度的第一手段。类名越含混，该类越有可能拥有过多的权责

    //  我们不应当让类变成一个万能的类

    //  10.2.1 单一权责原则

    //  单一权责原则认为，类或模块应有且只有一条加以修改的理由

    //  鉴别权责（修改的理由）常常帮助我们在代码中认识到并创建出更好的抽象

    //  问题是太多人在程序能工作时就以为万事大吉了

    //  系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达
    //  成期望的系统行为

    //  10.2.2 内聚

    //  类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种实体变量。通常而言，方式操作的变量越多，就越黏聚到
    //  类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性

    //  内聚性高，意味着类中的方法和变量互相依赖，相互结合成一个逻辑整体

    //  例：
    //  除了 size() 方法没有使用所有两个变量，其他的方法都用到了两个变量。这已经算是非常类聚的类了

    public class Stack {
        private int topOfStack = 0;
        List<Integer> elements = new LinkedList<>();

        public int size() {
            return topOfStack;
        }

        public void push(int element) {
            topOfStack++;
            elements.add(element);
        }

        public int pop() throws Exception {
            if (topOfStack == 0) {
                throw new Exception("PoppedWhenEmpty");
            }
            int element = elements.get(--topOfStack);
            elements.remove(topOfStack);
            return element;
        }
    }

    //  10.2.3 保持内聚性就会得到许多短小的类

    //  有时将达函数拆为许多小函数，往往也是将类拆分为多个小类的实际。程序会更加有组织，也会有更为透明的结构

    //  很多时候重构后的代码会比原来多上许多，有几个原因
    //  第一，重构后的程序采用了更长、更有描述性的变量名
    //  第二，重构后的程序将函数和类声明当做给代码添加注释的一种手段
    //  第三，采用了空格和格式技巧让程序更可读
}
